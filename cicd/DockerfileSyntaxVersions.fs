[<RequireQualifiedAccess>]
module CICD.DockerfileSyntaxVersions

open System.Diagnostics
open Fake.Core

module private Version =
    open System

    type Version =
        val Name : string
        val Raw : string
        val UpdatedAt : DateTime

        new(raw : string, updatedAt : DateTime) =
            let escaped = raw.Replace('.', '_').Replace ('-', '_')

            let name =
                if not (Char.IsLetter escaped[0]) then
                    $"v%s{escaped}"
                else
                    escaped

            {
                Name = name
                Raw = raw
                UpdatedAt = updatedAt
            }

    let inline parse (str : string, updatedAt : DateTime) = Version (str, updatedAt)

    let inline sort (left : Version) (right : Version) =
        let firstResult = DateTime.Compare (left.UpdatedAt, right.UpdatedAt) * -1

        if firstResult = 0 then
            String.Compare (left.Raw, right.Raw) * -1
        else
            firstResult

module private DockerHub =
    open System
    open System.Text.Json
    open FsHttp
    open Version

    let inline private dockerhubPath (repository : string) =
        $"https://hub.docker.com\
        /v2/namespaces/docker/repositories/%s{repository}/tags\
        ?page=1&page_size=100"

    let inline private get (url : string) =
        let sw = Stopwatch ()

        http {
            config_timeoutInSeconds 10.0
            GET url
        }
        |> (fun context ->
            if isVerbose then
                Trace.log $"Sending request to %s{context.header.target.address.Value}"
                sw.Start ()

            context
        )
        |> Request.send
        |> Response.assert2xx
        |> (fun response ->
            if isVerbose then
                let elapsed = sw.Elapsed
                sw.Reset ()
                Trace.log $"Responded %O{response.statusCode} [%d{toMs elapsed}ms]"

            response
        )
        |> Response.toJson
        |> (fun json ->
            json?next.GetString (),
            seq {
                let mutable e = json?results.EnumerateArray().GetEnumerator ()

                while e.MoveNext () do
                    yield e.Current
            }
        )
        |> (fun (page, images) ->
            page,
            seq {
                for image in images do
                    let name = image?name.GetString ()
                    let updatedAt = image?last_updated.GetDateTime ()

                    let mutable type' = JsonElement ()

                    if
                        (image.TryGetProperty ("content_type", &type')
                         && "image".Equals (type'.GetString ())
                         && not ("latest".Equals (name)))
                    then
                        yield (name, updatedAt)
            }
        )

    let getAllTags (repository : string) =
        let mutable result = Seq.empty
        let page = dockerhubPath repository

        let rec getTags (url : string) =
            let nextPage, versions = get url

            result <- Seq.append result versions

            if not (String.IsNullOrEmpty nextPage) then
                getTags nextPage

        getTags page

        result |> Seq.map parse |> Seq.sortWith sort |> Seq.readonly

module private Generate =
    open System
    open System.Text
    open System.IO
    open Version

    [<Literal>]
    let private eof = "\r\n"

    [<Literal>]
    let private indent = "    "

    let inline private (<~|) (stream : FileStream) (text : string) =
        text |> Encoding.UTF8.GetBytes |> stream.Write

        stream

    let inline private (<<|) (stream : FileStream) (text : string) =
        let line = [ text ; eof ] |> String.Concat

        stream <~| line

    let toFile
        (filePath : string)
        (repository : string)
        (namespace' : string)
        (values : Version seq)
        =
        let tempFilePath = $"%s{filePath}.temp"
        let lastIndex = (values |> Seq.length) - 1

        try
            use stream = File.Create (tempFilePath, 0, FileOptions.WriteThrough)

            stream <<| "(*" <~| indent <<| "WARNING:" <~| indent
            <<| "This file is automatically generated."
            <~| indent
            <<| "Any changes made here by hand will be overwritten!"
            <<| "*)"
            <~| eof

            <<| "/// <summary>"
            <~| "/// List of Dockerfile syntax versions from '"
            <~| repository
            <<| "' repository."
            <<| "/// </summary>"

            <<| "[<RequireQualifiedAccess>]"
            <~| "module Tuffenuff.DSL."
            <<| namespace'
            <~| eof

            |> ignore

            values
            |> Seq.iteri (fun i v ->
                stream <<| "/// <summary>" <<| "/// Sets the version of docker syntax to"
                <~| "/// <c>docker/"
                <~| repository
                <~| ":"
                <~| v.Raw
                <<| "</c>"
                <<| "/// </summary>"

                <<| "/// <example>"
                <~| "/// <c>"
                <~| v.Name
                <<| "</c> ->"
                <~| "/// <c># syntax=docker/"
                <~| repository
                <~| ":"
                <~| v.Raw
                <<| "</c>"
                <<| "/// </example>"

                <<| "/// <remarks>"
                <~| "/// Last updated at "
                <<| v.UpdatedAt.ToString ("yyyy-MM-ddTHH:mm:ss")
                <<| "/// </remarks>"

                <<| "/// <seealso cref=\"Tuffenuff.DSL.Comments.syntax\" />"

                <~| "let "
                <~| v.Name
                <~| " = syntax \"docker/"
                <~| repository
                <~| ":"
                <~| v.Raw
                <<| "\""

                |> ignore

                if i <> lastIndex then
                    stream <~| eof |> ignore
            )

        finally
            File.Move (tempFilePath, filePath, true)

let generate (filePath : string) (repository : string) (namespace' : string) =
    DockerHub.getAllTags repository
    |> Generate.toFile filePath repository namespace'
